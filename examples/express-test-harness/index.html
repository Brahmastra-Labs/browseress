<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Express Test Harness - Browseress</title>
  <style>
    body {
      font-family: monospace;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #f0f0f0;
    }
    .container {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }
    .status {
      padding: 10px;
      border-radius: 4px;
      margin-bottom: 15px;
    }
    .status.connected {
      background: #d4edda;
      color: #155724;
    }
    .status.disconnected {
      background: #f8d7da;
      color: #721c24;
    }
    button {
      background: #007bff;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      margin-right: 10px;
    }
    button:hover {
      background: #0056b3;
    }
    button:disabled {
      background: #6c757d;
      cursor: not-allowed;
    }
    .test-output {
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 4px;
      padding: 10px;
      font-size: 12px;
      white-space: pre-wrap;
      max-height: 500px;
      overflow-y: auto;
    }
    .pass { color: green; }
    .fail { color: red; }
    .skip { color: gray; }
    .error { color: red; font-weight: bold; }
    .test-selector {
      margin: 15px 0;
    }
    .test-selector select {
      padding: 8px;
      margin-right: 10px;
      border-radius: 4px;
      border: 1px solid #ced4da;
    }
    .test-category {
      display: inline-block;
      margin: 5px;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 12px;
    }
    .category-pass { background: #d4edda; color: #155724; }
    .category-adapted { background: #cce5ff; color: #004085; }
    .category-not-applicable { background: #f8d7da; color: #721c24; }
    .category-bug { background: #fff3cd; color: #856404; }
    .test-stats {
      margin: 10px 0;
      font-size: 14px;
    }
    .loading { opacity: 0.6; }
  </style>
</head>
<body>
  <h1>🧪 Express Test Harness - Browseress</h1>
  <p>Run Express.js tests in the browser using Browseress</p>

  <div class="container">
    <h2>Server Status</h2>
    <div id="status" class="status disconnected">Disconnected</div>
    <button id="startBtn" onclick="startServer()">Start Test Server</button>
    <button id="stopBtn" onclick="stopServer()" disabled>Stop Server</button>
    <button id="resetBtn" onclick="resetApp()" disabled>Reset App</button>
    <button id="clearBtn" onclick="clearOutput()">Clear Output</button>
    
    <div class="test-selector">
      <select id="testSelect" disabled>
        <option value="">Select a test suite...</option>
      </select>
      <button id="loadTestBtn" onclick="loadSelectedTest()" disabled>Load Test</button>
      <button id="runLoadedTestBtn" onclick="runLoadedTest()" disabled>Run Loaded Test</button>
    </div>
    
    <div id="testStats" class="test-stats"></div>
  </div>

  <div class="container">
    <h2>Test Output</h2>
    <div id="output" class="test-output">Waiting for Browseress to load...</div>
  </div>

  <script src="../../dist/browseress.bundle.js"></script>
  <script src="test-utils.js"></script>
  <script src="enhanced-test-loader.js"></script>
  <script src="test-transformer.js"></script>
  <script src="test-executor.js"></script>
  <script>
    let app = null;
    let transport = null;
    let serverStarted = false;
    let testLoader = null;
    let testTransformer = null;
    let testExecutor = null;
    let currentTestCode = null;
    let currentTestMetadata = null;
    
    function log(message, className = '') {
      const output = document.getElementById('output');
      const div = document.createElement('div');
      div.className = className;
      div.textContent = message;
      output.appendChild(div);
      output.scrollTop = output.scrollHeight;
    }
    
    function clearOutput() {
      document.getElementById('output').innerHTML = '';
    }
    
    function updateStatus(text, connected) {
      const statusDiv = document.getElementById('status');
      statusDiv.textContent = text;
      statusDiv.className = `status ${connected ? 'connected' : 'disconnected'}`;
      
      document.getElementById('startBtn').disabled = connected;
      document.getElementById('stopBtn').disabled = !connected;
      document.getElementById('resetBtn').disabled = !connected;
      
      if (!connected) {
        document.getElementById('testSelect').disabled = true;
        document.getElementById('loadTestBtn').disabled = true;
        document.getElementById('runLoadedTestBtn').disabled = true;
      }
    }
    
    async function initializeTestSystem() {
      testLoader = new EnhancedTestLoader();
      testTransformer = new TestTransformer();
      testExecutor = new TestExecutor();
      
      // Load available tests
      const tests = await testLoader.discoverTests();
      const select = document.getElementById('testSelect');
      
      tests.forEach(test => {
        const option = document.createElement('option');
        option.value = test.name;
        option.textContent = `${test.name} - ${test.description}`;
        select.appendChild(option);
      });
      
      log('Test system initialized');
    }
    
    async function startServer() {
      try {
        clearOutput();
        log('Starting test harness server...');
        
        // Initialize test system
        await initializeTestSystem();
        
        // Get Express and WebSocketTransport from bundle
        const express = window.browseress.express;
        const WebSocketTransport = window.browseress.WebSocketTransport;
        
        // Make Express utils available globally for tests
        window.expressUtils = window.browseress.expressUtils;
        
        // Create transport and connect
        transport = new WebSocketTransport('ws://localhost:3001');
        
        transport.on('connect', () => {
          log('Connected to relay server!');
          updateStatus('Connected - Ready to run tests', true);
          serverStarted = true;
          
          // Enable test selection
          document.getElementById('testSelect').disabled = false;
          document.getElementById('loadTestBtn').disabled = false;
        });
        
        transport.on('disconnect', () => {
          log('Disconnected from relay server');
          updateStatus('Disconnected', false);
          serverStarted = false;
        });
        
        transport.on('error', (err) => {
          log(`Transport error: ${err.message}`, 'error');
        });
        
        // Connect to relay
        await transport.connect();
        
      } catch (err) {
        log(`Error starting server: ${err.message}`, 'error');
        console.error(err);
        updateStatus('Failed to start', false);
      }
    }
    
    function stopServer() {
      if (transport) {
        log('Stopping server...');
        transport.close();
        transport = null;
        serverStarted = false;
        updateStatus('Disconnected', false);
      }
    }
    
    function resetApp() {
      log('Resetting application state...', 'status');
      
      // Create fresh Express app instance (transport remains stable)
      app = window.browseress.express();
      
      // Create new TestExecutor instance to clear test runner state
      testExecutor = new TestExecutor();
      
      // Clear TestRunner state
      TestRunner.reset();
      
      log('Application state reset complete');
    }
    
    // Simple test runner
    const TestRunner = {
      tests: [],
      beforeHooks: [],
      afterHooks: [],
      currentDescribe: null,
      
      reset() {
        this.tests = [];
        this.beforeHooks = [];
        this.afterHooks = [];
        this.currentDescribe = null;
      },
      
      describe(name, fn) {
        log(`\n${name}`, 'describe');
        fn();
      },
      
      it(name, fn) {
        TestRunner.tests.push({ name, fn });
      },
      
      before(fn) {
        TestRunner.beforeHooks.push(fn);
      },
      
      after(fn) {
        TestRunner.afterHooks.push(fn);
      },
      
      async run() {
        let passed = 0;
        let failed = 0;
        
        // Run before hooks
        for (const hook of this.beforeHooks) {
          try {
            await hook();
          } catch (err) {
            log('✗ before hook failed: ' + err.message, 'fail');
            return { passed, failed: 1 };
          }
        }
        
        // Run tests
        for (const test of this.tests) {
          try {
            await test.fn();
            log(`  ✓ ${test.name}`, 'pass');
            passed++;
          } catch (err) {
            log(`  ✗ ${test.name}`, 'fail');
            log(`    ${err.message}`, 'error');
            failed++;
          }
        }
        
        // Run after hooks
        for (const hook of this.afterHooks) {
          try {
            await hook();
          } catch (err) {
            log('✗ after hook failed: ' + err.message, 'fail');
          }
        }
        
        return { passed, failed };
      }
    };
    
    // Simple assertion helpers
    function expect(actual) {
      return {
        toBe(expected) {
          if (actual !== expected) {
            throw new Error(`Expected ${JSON.stringify(actual)} to be ${JSON.stringify(expected)}`);
          }
        },
        toEqual(expected) {
          if (JSON.stringify(actual) !== JSON.stringify(expected)) {
            throw new Error(`Expected ${JSON.stringify(actual)} to equal ${JSON.stringify(expected)}`);
          }
        },
        toContain(expected) {
          if (!actual.includes(expected)) {
            throw new Error(`Expected "${actual}" to contain "${expected}"`);
          }
        },
        toBeTruthy() {
          if (!actual) {
            throw new Error(`Expected ${actual} to be truthy`);
          }
        },
        toBeFalsy() {
          if (actual) {
            throw new Error(`Expected ${actual} to be falsy`);
          }
        },
        toBeUndefined() {
          if (actual !== undefined) {
            throw new Error(`Expected ${actual} to be undefined`);
          }
        },
        toMatch(expected) {
          if (!actual.match(expected)) {
            throw new Error(`Expected "${actual}" to match ${expected}`);
          }
        },
        toThrow(expectedError) {
          let threw = false;
          let actualError;
          try {
            actual();
          } catch (err) {
            threw = true;
            actualError = err;
          }
          if (!threw) {
            throw new Error(`Expected function to throw`);
          }
          if (expectedError && actualError.message !== expectedError) {
            throw new Error(`Expected error "${expectedError}" but got "${actualError.message}"`);
          }
        }
      };
    }
    
    // Simple supertest-like interface
    function request(app) {
      // Auto-listen the app on transport if not already listening
      // Check both _listening flag and if the transport is already set
      if (window._testTransport && !app._listening && !app._transport) {
        app.listen(window._testTransport);
        app._listening = true;
        app._transport = window._testTransport;
        console.log('[Test] Auto-listening app on transport');
      }
      
      // Create request object with all HTTP methods from http-stub polyfill
      const requestObj = {
        _app: app  // Store reference to the app being tested
      };
      
      // Common HTTP methods
      const methods = [
        'get', 'post', 'put', 'delete', 'patch', 'head', 'options',
        'connect', 'trace', 'copy', 'lock', 'mkcol', 'move', 'purge',
        'propfind', 'proppatch', 'unlock', 'bind', 'rebind', 'unbind',
        'acl', 'report', 'mkactivity', 'checkout', 'merge', 'm-search',
        'notify', 'subscribe', 'unsubscribe', 'search', 'link', 'unlink'
      ];
      
      // Add all methods to request object
      methods.forEach(method => {
        requestObj[method] = function(path) {
          return makeRequest(method.toUpperCase(), path, app);
        };
      });
      
      return requestObj;
    }
    
    function makeRequest(method, path, app) {
      const req = {
        method,
        path,
        headers: {},
        body: null,
        _app: app,  // Store reference to the app
        
        send(data) {
          this.body = data;
          return this;
        },
        
        set(name, value) {
          this.headers[name] = value;
          return this;
        },
        
        expect(status, body, callback) {
          if (typeof status === 'number' && typeof body === 'function') {
            callback = body;
            body = undefined;
          }
          
          // Store expectations
          this.expectedStatus = status;
          this.expectedBody = body;
          this.expectCallback = callback;
          
          // If callback is provided, execute the request immediately (like real supertest)
          if (callback) {
            // Use setTimeout to ensure this happens after the current call stack
            setTimeout(() => {
              this.end(callback);
            }, 0);
          }
          
          // Return this for chaining
          return this;
        },
        
        async end(callback) {
          // Use callback from expect() if not provided
          callback = callback || this.expectCallback;
          
          try {
            // Instead of making HTTP request, simulate request through the app
            // Get the app from the stored reference
            const app = this._app;
            if (!app) {
              throw new Error('No app provided to request');
            }
            
            // Get the http module from browseress
            const http = window.browseress.http;
            
            // Create mock request object inheriting from IncomingMessage
            const mockReq = new http.IncomingMessage();
            Object.assign(mockReq, {
              method: this.method,
              url: this.path,
              path: this.path,
              headers: {
                'content-type': 'application/json',
                ...this.headers
              },
              body: this.body,
              query: {},
              params: {},
              // Required by Express
              httpVersion: '1.1',
              httpVersionMajor: 1,
              httpVersionMinor: 1,
              connection: {
                remoteAddress: '127.0.0.1'
              },
              // Method to get headers
              get(header) {
                return this.headers[header.toLowerCase()];
              },
              // Stream-like methods Express might expect
              on() { return this; },
              once() { return this; },
              emit() { return this; },
              pipe() { return this; },
              resume() { return this; },
              pause() { return this; }
            });
            
            let responseData = '';
            let responseHeaders = {};
            let responseStatus = 200;
            
            // Create mock response object inheriting from ServerResponse
            const mockRes = new http.ServerResponse();
            
            // Store original end method
            const originalEnd = mockRes.end;
            
            // Override methods to capture data
            mockRes.end = function(data) {
              if (data) {
                // Only set responseData if nothing has been written yet
                if (!responseData) {
                  responseData = data;
                } else {
                  // Append to existing data
                  responseData += data;
                }
              }
              responseStatus = this.statusCode;
              responseHeaders = this.headers;
              // Call original end to emit events
              return originalEnd.call(this, data);
            };
            
            // Override write to capture data
            const originalWrite = mockRes.write;
            mockRes.write = function(chunk) {
              responseData += chunk;
              return originalWrite.call(this, chunk);
            };
            
            // Don't override Express methods - let Express add them through prototype chain
            // This ensures we get the real Express behavior including JSON spacing, etc.
            
            // Handle the request through the app
            console.log('[Request] Handling through app.handle...');
            await new Promise((resolve, reject) => {
              const timeout = setTimeout(() => {
                console.error('[Request] Timeout after 5 seconds');
                console.error('[Request] mockRes.finished:', mockRes.finished);
                console.error('[Request] mockRes.headersSent:', mockRes.headersSent);
                reject(new Error('Request timeout'));
              }, 5000);
              
              // Listen for finish event to know when response is complete
              mockRes.once('finish', () => {
                console.log('[Request] Response finished');
                clearTimeout(timeout);
                resolve();
              });
              
              try {
                console.log('[Request] Calling app.handle with mockReq:', mockReq.method, mockReq.path);
                app.handle(mockReq, mockRes, (err) => {
                  console.log('[Request] app.handle callback called, err:', err);
                  if (err) {
                    clearTimeout(timeout);
                    reject(err);
                  }
                  // Note: Don't resolve here, wait for 'finish' event
                });
              } catch (err) {
                console.error('[Request] Error calling app.handle:', err);
                clearTimeout(timeout);
                reject(err);
              }
            });
            
            // Parse response data
            let body;
            try {
              body = JSON.parse(responseData);
            } catch (e) {
              body = responseData;
            }
            
            const res = {
              status: responseStatus || mockRes.statusCode,
              headers: responseHeaders,
              body: body,
              text: responseData
            };
            
            // Check expectations
            if (this.expectedStatus && res.status !== this.expectedStatus) {
              const err = new Error(`Expected status ${this.expectedStatus} but got ${res.status}`);
              if (callback) callback(err);
              else throw err;
              return;
            }
            
            if (this.expectedBody !== undefined) {
              const actualBody = typeof res.body === 'string' ? res.body : JSON.stringify(res.body);
              const expectedBody = typeof this.expectedBody === 'string' ? this.expectedBody : JSON.stringify(this.expectedBody);
              if (actualBody !== expectedBody) {
                const err = new Error(`Expected body ${expectedBody} but got ${actualBody}`);
                if (callback) callback(err);
                else throw err;
                return;
              }
            }
            
            if (callback) callback(null, res);
            return res;
          } catch (err) {
            if (callback) callback(err);
            else throw err;
          }
        }
      };
      
      return req;
    }
    
    // Load selected test
    async function loadSelectedTest() {
      const select = document.getElementById('testSelect');
      const testName = select.value;
      
      if (!testName) {
        log('Please select a test suite', 'error');
        return;
      }
      
      try {
        log(`Loading test: ${testName}...`);
        
        // Load the test file
        const testCode = await testLoader.loadTestFile(testName);
        const metadata = testLoader.getTestMetadata(testName);
        
        log(`Test loaded successfully. ${metadata.testCount} tests found.`);
        
        // Transform the test
        const transformed = testTransformer.transformTest(testCode, metadata);
        
        // Check for transformation errors
        if (transformed.error) {
          log(`Transformation Error: ${transformed.error}`, 'error');
          if (transformed.unhandledRequires) {
            log('Unhandled modules:', 'error');
            transformed.unhandledRequires.forEach(mod => log(`  - ${mod}`, 'error'));
            log('\nThese modules need to be added to the transformer or mocked in test-utils.js', 'error');
          }
          document.getElementById('runLoadedTestBtn').disabled = true;
          return;
        }
        
        // Display transformation info
        if (transformed.category === 'NOT_APPLICABLE') {
          log(`Test category: NOT_APPLICABLE - ${transformed.reason}`, 'error');
          document.getElementById('runLoadedTestBtn').disabled = true;
          return;
        }
        
        log(`Test category: ${transformed.category}`);
        if (transformed.modifications.length > 0) {
          log('Transformations applied:');
          transformed.modifications.forEach(mod => {
            if (mod.startsWith('ERROR:')) {
              log(`  - ${mod}`, 'error');
            } else {
              log(`  - ${mod}`);
            }
          });
        }
        
        // Store for execution
        currentTestCode = transformed.code;
        currentTestMetadata = transformed.metadata;
        
        // Enable run button
        document.getElementById('runLoadedTestBtn').disabled = false;
        
        // Show test stats
        updateTestStats(transformed);
        
      } catch (error) {
        log(`Error loading test: ${error.message}`, 'error');
        console.error(error);
      }
    }
    
    // Run loaded test
    async function runLoadedTest() {
      if (!currentTestCode) {
        log('No test loaded', 'error');
        window._testCompletionPromise = Promise.resolve({ error: 'No test loaded', passed: 0, failed: -1 });
        return;
      }
      
      if (!serverStarted || !transport) {
        log('Error: Server not connected. Click "Start Test Server" first.', 'error');
        window._testCompletionPromise = Promise.resolve({ error: 'Server not connected', passed: 0, failed: -1 });
        return;
      }
      
      // Don't clear output immediately - preserve loading messages
      log(`\nRunning test: ${currentTestMetadata.name}\n`);
      
      // Create a promise that Playwright can wait for
      window._testCompletionPromise = new Promise(async (resolve) => {
        try {
        console.log('[Test] Starting test execution...');
        // Store the transport globally so supertest mock can use it
        window._testTransport = transport;
        
        // Make request function available globally for the test
        window.supertest = request;
        
        // Make process available globally like in Node.js
        if (!window.process && window.browseress?.process) {
          window.process = window.browseress.process;
          // Also make it available as just 'process' for compatibility
          globalThis.process = window.process;
          console.log('[Test] Set window.process and global process from browseress.process');
        } else {
          console.log('[Test] window.process already exists or browseress.process not available');
          console.log('[Test] window.process:', window.process);
          console.log('[Test] window.browseress?.process:', window.browseress?.process);
        }
        
        
        // Create test context
        const testContext = {
          describe: null, // Will be set by executor
          it: null,      // Will be set by executor
          before: null,  // Will be set by executor
          after: null,   // Will be set by executor
          beforeEach: null,
          afterEach: null,
          expect,
          assert: window.assert,
          request: window.supertest,
          express: window.browseress.express,
          transport,
          after: window.after,
          testUtils: window.testUtils
          // Note: process is NOT in context - it's a global like in Node.js
        };
        
        // Execute the test using TestExecutor
        const startTime = Date.now();
        
        const executionResult = await testExecutor.executeTest(currentTestCode, testContext);
        
        const duration = Date.now() - startTime;
        
        if (!executionResult.success) {
          log(`Failed to execute test: ${executionResult.error}`, 'error');
          if (executionResult.stack) {
            console.error('Stack trace:', executionResult.stack);
          }
          // Resolve with error info
          resolve({ error: executionResult.error, passed: 0, failed: -1 });
          return;
        }
        
        log('Express app started on http://localhost:8080\n');
        
        // Display all test results from executor
        const results = executionResult.results || [];
        let passed = 0;
        let failed = 0;
        
        results.forEach(result => {
          if (result.suite !== 'root') {
            log(`\n${result.suite}`);
          }
          
          if (result.status === 'passed') {
            log(`  ✓ ${result.name}`, 'pass');
            passed++;
          } else if (result.status === 'failed') {
            log(`  ✗ ${result.name}`, 'fail');
            log(`    ${result.error}`, 'error');
            if (result.stack) {
              console.error('Stack trace:', result.stack);
            }
            failed++;
          }
        });
        
        const testResults = { passed, failed };
        
        // Display results
        log(`\n${'='.repeat(50)}`);
        log(`Test: ${currentTestMetadata.name}`);
        log(`Category: ${currentTestMetadata.category}`);
        log(`Duration: ${duration}ms`);
        log(`Tests: ${testResults.passed} passed, ${testResults.failed} failed, ${testResults.passed + testResults.failed} total`);
        
        // Show common error patterns
        const errorPatterns = {};
        results.forEach(result => {
          if (result.status === 'failed' && result.error) {
            const pattern = result.error.match(/(\w+Error): (.+?)(?:\n|$)/)?.[0] || result.error.substring(0, 50);
            errorPatterns[pattern] = (errorPatterns[pattern] || 0) + 1;
          }
        });
        
        if (Object.keys(errorPatterns).length > 0) {
          log('\nCommon errors:');
          Object.entries(errorPatterns)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 5)
            .forEach(([error, count]) => {
              log(`  ${count}x: ${error}`, 'error');
            });
        }
        
        if (testResults.failed === 0) {
          log('\n✅ All tests passed!', 'pass');
        } else {
          log('\n❌ Some tests failed', 'fail');
        }
        
        // Resolve the promise with the final results
        resolve(testResults);
        
      } catch (error) {
        log(`Error running test: ${error.message}`, 'error');
        console.error(error);
        // Resolve with error info so Playwright doesn't hang
        resolve({ error: error.message, passed: 0, failed: -1 });
      } finally {
        // Clean up
        app = null;
      }
    });
    }
    
    // Update test statistics display
    function updateTestStats(transformed) {
      const statsDiv = document.getElementById('testStats');
      const metadata = transformed.metadata;
      
      let html = `
        <div>Test: <strong>${metadata.name}</strong></div>
        <div>Tests found: ${metadata.testCount}</div>
        <div>Category: <span class="test-category category-${transformed.category.toLowerCase()}">${transformed.category}</span></div>
      `;
      
      if (metadata.requireStatements && metadata.requireStatements.length > 0) {
        html += '<div>Dependencies: ';
        metadata.requireStatements.forEach(req => {
          html += `<code>${req.module}</code> `;
        });
        html += '</div>';
      }
      
      statsDiv.innerHTML = html;
    }
    
    // Initialize on load
    window.addEventListener('load', () => {
      log('Express Test Harness loaded');
      log('This harness demonstrates running Express.js tests in the browser.');
      log('\n1. Click "Start Test Server" to connect to relay server');
      log('2. Select a test suite from the dropdown and click "Load Test"');
      log('3. Click "Run Loaded Test" to execute the test suite');
      log('\nMake sure relay server is running on port 3001!');
    });
  </script>
</body>
</html>